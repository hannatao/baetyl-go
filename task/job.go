package task

import (
	"reflect"
	"sync"

	"github.com/google/uuid"

	"github.com/baetyl/baetyl-go/v2/errors"
	"github.com/baetyl/baetyl-go/v2/models"
)

var (
	ErrJobExist    = errors.New("failed to create job, job exists")
	ErrJobNotExist = errors.New("failed to find job in registry")
	ErrNotFunc     = errors.New("failed to register interface, not a function")
	ErrArgs        = errors.New("failed to register function, invalid arguments")
)

type jobRegister struct {
	JobMap     map[string][]reflect.Value
	JobMapLock sync.RWMutex
}

var JobRegister = jobRegister{
	JobMap: map[string][]reflect.Value{},
}

// Register Register a job with functions.
// PARAMS:
//   - jobName: specific job name
//   - handlers: function list, the previous output will be the input of the next function.
// RETURNS:
//   error: if has error else nil
func (j *jobRegister) Register(jobName string, handlers ...interface{}) error {
	j.JobMapLock.Lock()
	defer j.JobMapLock.Unlock()
	if _, ok := j.JobMap[jobName]; ok {
		return ErrJobExist
	}

	j.JobMap[jobName] = make([]reflect.Value, len(handlers))
	for i, handler := range handlers {
		h := reflect.ValueOf(handler)
		if h.Kind() != reflect.Func {
			delete(j.JobMap, jobName)
			return ErrNotFunc
		}
		j.JobMap[jobName][i] = reflect.ValueOf(handler)
	}
	return nil
}

// NewTask Validate this task and fill with uuid.
// PARAMS:
//   - task: task generated by user
// RETURNS:
//   Task: pointer to the origin task
//   error: if has error else nil
func (j *jobRegister) NewTask(task *models.Task) (*models.Task, error) {
	j.JobMapLock.RLock()
	defer j.JobMapLock.RUnlock()

	handlers, ok := j.JobMap[task.JobName]
	if !ok {
		return nil, ErrJobNotExist
	}

	if handlers[0].Type().NumIn() != len(task.Args) {
		return nil, ErrArgs
	}

	id, _ := uuid.NewUUID()
	task.Id = id.String()
	return task, nil
}
